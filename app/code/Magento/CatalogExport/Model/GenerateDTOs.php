<?php
/**
 * Copyright © Magento, Inc. All rights reserved.
 * See COPYING.txt for license details.
 */
declare(strict_types=1);

namespace Magento\CatalogExport\Model;

use Magento\DataExporter\Config\ConfigInterface;
use Magento\Framework\Exception\FileSystemException;
use Magento\Framework\Filesystem\Driver\File;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\PsrPrinter;
use Magento\Framework\App\Filesystem\DirectoryList;
use Magento\Framework\Code\Reader\ScalarTypesProvider;

/**
 * Class for generating ExportApi DTOs
 */
class GenerateDTOs
{
    /**
     * Output directory for autogenerated export DTOs
     */
    private const EXPORT_DTO_OUTPUT_DIR = '/Magento/CatalogExportApi/Api/Data';

    /**
     * @var File
     */
    private $fileDriver;

    /**
     * @var ConfigInterface
     */
    private $config;

    /**
     * @var DirectoryList
     */
    private $dirList;

    /**
     * @var array
     */
    private $baseConfigEntities;

    /**
     * @var ScalarTypesProvider
     */
    private $scalarTypes;

    /**
     * @param File $fileDriver
     * @param ConfigInterface $config
     * @param DirectoryList $dirList
     * @param ScalarTypesProvider $scalarTypes
     * @param array $baseConfigEntities
     */
    public function __construct(
        File $fileDriver,
        ConfigInterface $config,
        DirectoryList $dirList,
        ScalarTypesProvider $scalarTypes,
        array $baseConfigEntities
    ) {
        $this->fileDriver = $fileDriver;
        $this->config = $config;
        $this->dirList = $dirList;
        $this->scalarTypes = $scalarTypes;
        $this->baseConfigEntities = $baseConfigEntities;
    }

    /**
     * Generate export DTOs
     *
     * @return void
     * @throws \RuntimeException
     */
    public function execute(): void
    {
        try {
            $outputDir = $this->dirList->getPath(DirectoryList::GENERATED_CODE) . self::EXPORT_DTO_OUTPUT_DIR;
            $parsedEntities = [];
            foreach ($this->baseConfigEntities as $node) {
                $parsedEntities[] = $this->getConfig($node);
            }
            $parsedArray = \array_merge(...$parsedEntities);
            $classesData = $this->prepareDtoClassData($parsedArray);
            $this->createDirectory($outputDir);
            $this->generateFiles($classesData, $outputDir);
        } catch (\Throwable $e) {
            throw new \RuntimeException('Could not generate ExportApi DTO\'s ' . $e);
        }
    }

    /**
     * Resolve namespace
     *
     * @param string $filePath
     * @return string
     */
    private function resolveNameSpace(string $filePath): string
    {
        $filePath = trim($filePath, DIRECTORY_SEPARATOR);
        return str_replace('/', '\\', strstr($filePath, 'Magento'));
    }

    /**
     * Return entities config.
     *
     * @param string $entity
     * @param array $parsedArray
     * @return array
     */
    private function getConfig(string $entity, $parsedArray = []): array
    {
        $parsedEntity = $this->config->get($entity);
        if ($parsedEntity) {
            $parsedArray[$entity] = $parsedEntity;

            foreach ($parsedEntity['field'] as $field) {
                if (!$this->config->isScalar($field['type'])) {
                    $parsedArray = $this->getConfig($field['type'], $parsedArray);
                }
            }
        }
        return $parsedArray;
    }

    /**
     * Build structure required to build DTO
     *
     * @param array $parsedArray
     * @return array
     */
    private function prepareDtoClassData(array $parsedArray): array
    {
        $result = [];
        if (empty($parsedArray)) {
            return $result;
        }

        foreach ($parsedArray as $schemaConfig) {
            foreach ($schemaConfig['field'] as &$field) {
                $field['type'] = $this->mapType($field['type']);
                $field['name'] = lcfirst(str_replace('_', '', ucwords($field['name'], '_')));
            }
            $result[$schemaConfig['name']] = $schemaConfig['field'];
        }

        return $result;
    }

    /**
     * Map type
     *
     * @param string $type
     * @return string
     */
    private function mapType(string $type): string
    {
        switch ($type) {
            case 'Int':
                $type = 'int';
                break;
            case 'ID':
            case 'String':
                $type = 'string';
                break;
            case 'Boolean':
                $type = 'bool';
                break;
            case 'Float':
                $type = 'float';
                break;
        }

        return $type;
    }

    /**
     * Create directory
     *
     * @param string $outPutLocation
     * @return void
     * @throws FileSystemException
     */
    private function createDirectory(string $outPutLocation): void
    {
        if (!$this->fileDriver->isExists($outPutLocation)) {
            $this->fileDriver->createDirectory($outPutLocation, 0775);
        }
    }

    /**
     * Generate files
     *
     * @param array $generateArray
     * @param string $baseFileLocation
     * @return void
     * @throws FileSystemException
     * @SuppressWarnings(PHPMD.NPathComplexity)
     * @SuppressWarnings(PHPMD.CyclomaticComplexity)
     */
    private function generateFiles(array $generateArray, string $baseFileLocation): void
    {
        $baseNameSpace = $this->resolveNameSpace($baseFileLocation);
        foreach ($generateArray as $className => $phpClassFields) {
            $file = new PhpFile();
            $file->addComment('Copyright © Magento, Inc. All rights reserved.');
            $file->addComment('See COPYING.txt for license details.');
            $file->setStrictTypes();
            $namespace = $file->addNamespace($baseNameSpace);
            $class = $this->generateClass($className, $baseNameSpace, $namespace);
            foreach ($phpClassFields as $field) {
                $repeated = $field['repeated'];
                $name = $field['name'];
                $type = $repeated === true ? $field['type'] . '[]' : $field['type'];
                $this->addProperty($class, $name, $type);
                $this->generateGetter($class, $type, $name, $repeated, $baseNameSpace);
                $this->generateSetter($class, $type, $name, $repeated, $baseNameSpace);
            }
            $print = new PsrPrinter();
            $this->writeToFile($baseFileLocation . '/' . $className . '.php', $print->printFile($file));
        }
    }

    /**
     * Generate object class
     *
     * @param string $className
     * @param string $baseNameSpace
     * @param PhpNamespace $namespace
     * @return ClassType
     */
    private function generateClass(string $className, string $baseNameSpace, PhpNamespace $namespace): ClassType
    {
        $class = $namespace->addClass($className);
        $class->addComment($className . ' entity');
        $class->addComment('');
        $class->addComment('phpcs:disable Magento2.PHP.FinalImplementation');
        $class->addComment('@SuppressWarnings(PHPMD.BooleanGetMethodName)');
        $class->addComment('@SuppressWarnings(PHPMD.TooManyFields)');
        $class->addComment('@SuppressWarnings(PHPMD.ExcessivePublicCount)');
        $class->addComment('@SuppressWarnings(PHPMD.ExcessiveClassComplexity)');
        $class->addComment('@SuppressWarnings(PHPMD.CouplingBetweenObjects)');
        return $class;
    }

    /**
     * Add a property
     *
     * @param ClassType $class
     * @param string $name
     * @param string $type
     * @return void
     */
    private function addProperty(ClassType $class, string $name, string $type): void
    {
        $property = $class->addProperty($name)->setPrivate();
        $property->addComment('@var ' . $type . '|null');
    }

    /**
     * Generate a getter method
     *
     * @param ClassType $class
     * @param string $type
     * @param string $name
     * @param bool $repeated
     * @param string $baseNameSpace
     */
    private function generateGetter(
        ClassType $class,
        string $type,
        string $name,
        bool $repeated,
        string $baseNameSpace
    ): void {
        $method = $class->addMethod('get' . ucfirst($name));
        $method->addComment('Get ' . strtolower(preg_replace('/(?<!\ )[A-Z]/', ' $0', $name)));
        $method->addComment('');

        /** Docblock @return */
        $method->addComment('@return ' . $type . '|null');

        /** Return typehint */
        if (true === $repeated) {
            $method->setReturnType('array');
        } else {
            $method->setReturnType($this->resolveTypeWithNameSpace($baseNameSpace, $type));
        }
        $method->setReturnNullable();
        $method->addBody('return $this->' . $name . ';');
    }

    /**
     * Generate a setter method
     *
     * @param ClassType $class
     * @param string $type
     * @param string $name
     * @param bool $repeated
     * @param string $baseNameSpace
     */
    private function generateSetter(
        ClassType $class,
        string $type,
        string $name,
        bool $repeated,
        string $baseNameSpace
    ): void {
        $method = $class->addMethod('set' . ucfirst($name));
        $method->addComment('Set ' . strtolower(preg_replace('/(?<!\ )[A-Z]/', ' $0', $name)));
        $method->addComment('');

        /** Docblock @param */
        $method->addComment('@param ' . $type . '|null $' . $name);
        $method->addComment('@return void');

        /** Variable typehint */
        if (true === $repeated) {
            $method->addParameter($name, null)->setType('array')->setNullable();
        } else {
            $method->addParameter($name, null)
                ->setType($this->resolveTypeWithNameSpace($baseNameSpace, $type))
                ->setNullable();
        }
        $method->setReturnType('void');
        $method->addBody('$this->' . $name . ' = $' . $name . ';');
    }

    /**
     * Add namespace to type if it is not scalar
     *
     * @param $baseNameSpace
     * @param $type
     * @return string
     */
    private function resolveTypeWithNameSpace($baseNameSpace, $type): string
    {
        if (!in_array($type, $this->scalarTypes->getTypes())) {
            return '\\' . $baseNameSpace . '\\' . $type;
        }
        return $type;
    }

    /**
     * Write to file
     *
     * @param string $fileLocation
     * @param string $output
     * @return void
     * @throws FileSystemException
     */
    private function writeToFile(string $fileLocation, string $output): void
    {
        $resource = $this->fileDriver->fileOpen($fileLocation, 'w');
        $this->fileDriver->fileWrite($resource, $output);
        $this->fileDriver->fileClose($resource);
    }
}
